{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to SmartWalk Docs This page contains the documentation for SmartWalk , a web application for keyword-aware walking route search. Check out the Demo (although not connected to a backend) to get a sense of how the application might look and feel. User's documentation gives an overview of how to use the application and accomplish basic tasks, such as searching for and managing entities. Programmer's guide brings clarity into the application architecture and code organization. Code documentation for the frontend and backend can be accessed at prg-frontend and prg-backend , respectively. Administrator's guide provides instructions for preparing a dataset, running the application in development or production mode on a personal computer, and troubleshooting potential issues. Motivation Most of the mainstream web mapping applications ( Mapy.cz , Google Maps , etc.) implement explicit location-based direction search. A typical workflow involves building a sequence, with the following three steps applied for each waypoint. Search for places that might satisfy imposed constraints (e.g., a museum free of charge). Append one of them to the sequence, with possible manual reordering. New path is presented to the user right after the sequence configuration is altered. In contrast, SmartWalk enables users to formulate search queries in terms of categories . A category is composed of a keyword (castle, museum, statue, etc.) and attribute filters (has an image, with WiFi, capacity \u2265 N , etc.). For a place to be matched by a category, it must satisfy all constraints. Given a starting point, destination, set of categories, and maximum walking distance, SmartWalk attempts to find routes with a length never longer than the predefined limit that visit at least one place from each category. Besides routes, the application also supports place and standard location-based direction search. Credits The pictures and diagrams were created with Draw.io drawing software. Map tiles in the user interface are attributed to \u00a9 OpenStreetMap contributors.","title":"Home"},{"location":"#welcome-to-smartwalk-docs","text":"This page contains the documentation for SmartWalk , a web application for keyword-aware walking route search. Check out the Demo (although not connected to a backend) to get a sense of how the application might look and feel. User's documentation gives an overview of how to use the application and accomplish basic tasks, such as searching for and managing entities. Programmer's guide brings clarity into the application architecture and code organization. Code documentation for the frontend and backend can be accessed at prg-frontend and prg-backend , respectively. Administrator's guide provides instructions for preparing a dataset, running the application in development or production mode on a personal computer, and troubleshooting potential issues.","title":"Welcome to SmartWalk Docs"},{"location":"#motivation","text":"Most of the mainstream web mapping applications ( Mapy.cz , Google Maps , etc.) implement explicit location-based direction search. A typical workflow involves building a sequence, with the following three steps applied for each waypoint. Search for places that might satisfy imposed constraints (e.g., a museum free of charge). Append one of them to the sequence, with possible manual reordering. New path is presented to the user right after the sequence configuration is altered. In contrast, SmartWalk enables users to formulate search queries in terms of categories . A category is composed of a keyword (castle, museum, statue, etc.) and attribute filters (has an image, with WiFi, capacity \u2265 N , etc.). For a place to be matched by a category, it must satisfy all constraints. Given a starting point, destination, set of categories, and maximum walking distance, SmartWalk attempts to find routes with a length never longer than the predefined limit that visit at least one place from each category. Besides routes, the application also supports place and standard location-based direction search.","title":"Motivation"},{"location":"#credits","text":"The pictures and diagrams were created with Draw.io drawing software. Map tiles in the user interface are attributed to \u00a9 OpenStreetMap contributors.","title":"Credits"},{"location":"adm/","text":"Administrator's guide Data preparation provides a step-by-step procedure on how to integrate data from six different sources and prepare it for running SmartWalk. Once data is ready, read Running the app to learn how to get the application up and running in development and production settings. If something is not working as expected, you might find Troubleshooting helpful before searching for a solution on the Web. Prerequisites SmartWalk is essentially cross-platform. However, Unix utilities simplify certain aspects of system maintenance. We assume that the application will run on Unix-like environments, such as Linux or Windows Subsystem for Linux . Please ensure that the following programs are installed on the target system: Docker .NET SDK v6.0 Git GNU Bash, Make, Tar, and Wget Node.js v18.x (install via nvm ) Warning If mentioned, preserve versions of packages due to library dependencies. Clone the repository with submodules and navigate to its root folder: $ git clone --recurse-submodules https://github.com/zhukovdm/smartwalk.git $ cd ./smartwalk/ ADVICE: Docker-related commands require the current user to be a member of the docker group to avoid using sudo (or similar) repeatedly. See details at Manage Docker as a non-root user . Data preparation This section explains how to prepare data for two system components: the Database (entity store and index) and the Routing engine . Warning The complexity of extracting and building data structures depends on the size of a particular region and might be time- and resource-consuming, especially when processing OSM dumps. Initialization Navigate to the data folder, assuming you are in the root folder of the smartwalk repository: $ cd ./data/ Decide which part of the world you are interested in. Download the corresponding pbf -file at Geofabrik , and store it in the ./assets/osm-maps/ folder. As an example, the following command makes use of the wget utility to obtain the latest dump of the Czech Republic: $ wget \\ -O ./assets/osm-maps/czech-republic-latest.osm.pbf \\ https://download.geofabrik.de/europe/czech-republic-latest.osm.pbf Open Makefile and set the value of REGION_FILE accordingly. Some of the OSM dumps are quite large and additional refinement might be necessary. There are four variables REGION_X , where suffix X can be any of W (West), N (North), E (East), or S (South), defining a bounding box. Entities outside this box are filtered out. To switch off filtering, set W=-180.0 , N=85.06 , E=180.0 , and S=-85.06 (see EPSG3857 for details). Create folders for storing data, and restore project dependencies: $ make init Routing engine Build a data structure for the routing engine: $ make routing-engine The command pulls this Docker image and builds the search structure in several consecutive phases. The results are stored in the ./assets/routing-engine/ folder. ADVICE: An instance of OSRM backend is able to load only one osrm -file at a time. This limitation can be overcome via merging (see osmosis ). ADVICE: It is possible to extract routing data for several regions and keep all files in the same folder as long as the original pbf -files have distinct names. Use environment variables to select a part of the world on engine start. Entity store and index Start up a containerized database instance: $ docker compose up -d ADVICE: Enter docker container ls repeatedly to print out the list of existing containers. Wait until smartwalk-database is healthy. Clean up all previous data, create new collections and indexes: $ make database-init Obtain the most popular OSM keys from Taginfo and store results in the ./assets/taginfo/ folder: $ make taginfo ADVICE: A list of tags can be extended by altering Makefile , although this is not enough to enable their full potential. The constructor of KeywordExtractor shall reflect changes as well. Never remove tags from the list as it may brake things unexpectedly. Modifying tag list is not a typical operation and may require deeper knowledge of the system. Extract entities from the pbf -file: $ make database-osm As part of the procedure, the routine makes several GET requests to the Overpass API . A query is configured to time out after 100 seconds, though the server usually responds within the first 10. ADVICE: To make queries feasible for the Overpass API, the selected bounding box is divided into smaller pieces. The recipe has two switches --rows and --cols defining the grid. Create stubs for new entities from the Wikidata knowledge graph: $ make database-wikidata-create The script attempts to fetch data from a SPARQL endpoint. Requests may time out after one minute. Large regions are more likely to result in failures. Hence, the numeric constants were specifically chosen for the test setup and may not be suitable for other cases. ADVICE: The recipe has --rows and --cols switches with functionality similar to database-osm . Enrich the current dataset with information from Wikidata : $ make database-wikidata-enrich Enrich the current dataset with information from the DBPedia knowledge graph: $ make database-dbpedia Collect supporting data to aid autocomplete functionality: $ make advice Finally, stop the database instance: $ docker compose down All relevant files are stored in the ./assets/database/ folder. Incremental updates The system supports incremental updates to incorporate new versions of datasets. It is possible to re-run blue-highlighted commands with no impact on data integrity. The programs are designed to update only defined properties without replacing entities, acting as an idempotent function. advice should be re-generated whenever the database state is altered. Dumping database Dump the current database state: $ make dump The command creates keyword.txt and place.txt in the ./assets/dump/ folder. If necessary, archive these files for publishing: $ cd ./assets/dump/ $ tar -czf smartwalk-[kind]-[timestamp].tar.gz *.txt Restoring database Clean up the database and restore the state from files: $ make database-init && make restore The restore procedure expects both files to be in the ./assets/dump/ folder. Otherwise, it fails. Examples of archived dumps can be found here . Those having prod in their names are the most data-rich covering beautiful Prague . If necessary, unpack a downloaded archive as follows: $ cd ./assets/dump/ $ tar -xzf smartwalk-[kind]-[timestamp].tar.gz Running the app The purpose of this section is to explain how to start the system in development and production modes. We assume that you are in the root folder of the smartwalk repository and all relevant data have been extracted or restored and are available in their respective folders. Development environment This environment is intended primarily for developers and testers. It enables controlling parts of the system independently. There are four system components involved in the setup: the frontend, backend, database, and routing engine. The first two run directly in the terminal, while the last two are Docker containers. The table below summarizes their roles and the mapping of system ports. Component Ports Role database localhost:27017 Entity store and index routing localhost:5000 Routing engine backend localhost:5017 Application logic (hot reload) frontend localhost:3000 Static files (hot reload) Note For convenience, components can be started and stopped directly from the smartwalk root folder. Please refer to Makefile . Recipe names follow the pattern [component_name]-dev[-stop] . Database Start and stop an instance of database using database-dev[-stop] from Makefile . Routing engine Start and stop an instance of routing engine using routing-dev[-stop] from Makefile . Set OSRM_REGION_FILE in .env.development to load a region other than the Czech Republic. Backend The project is located in ./app/backend/ . Run dotnet run from there to start the backend in the terminal, and stop it by pressing Ctrl+C . Read more about other commands in README.md . Warning This component requires the database to be up and running. Otherwise, it fails to start. The source code uses SMARTWALK_MONGO_CONN_STR and SMARTWALK_OSRM_BASE_URL environment variables. Adjust launchSettings.json respectively if you wish to alter the default port configuration. Frontend Find the project in ./app/frontend/ . Run npm start from there to start the frontend in the terminal, and stop it by pressing Ctrl+C . Learn more about other commands in README.md . The source code uses REACT_APP_SMARTWALK_API_ORIGIN environment variable. Set its value in the .env.development file if you wish to run backend on another port. Production environment This environment is a tightly coupled bundle consisting of four interconnected Docker containers; its detailed schema is shown in the picture below. Note The database exposes port 27017 for manual diagnostic and performance testing. Hide it if none of the mentioned reasons is your case. Start and stop production environment from the root folder of the repo: $ make prod[-stop] ADVICE: All containers implement healthcheck, run docker container ls to see their state. The respective environment variables are defined in the .env.production file. Troubleshooting WSL runs out of memory If your WSL consumes too much memory, Windows might suddenly terminate the entire process without prior notice. Try to mitigate the issue by extending the swap file; set swap=XXGB in the .wslconfig file. For more details, see Example .wslconfig file . A container starts for too long If any of the containers is unhealthy or starting for too long (healthcheck has failed repeatedly on the background), replace [container_name] placeholder by the name of a problematic instance and press Enter to find out the reason: $ docker container ls -a CONTAINER ID IMAGE ... NAMES ... ... ... ... 377fe35d4472 smartwalk/proxy:v1.0.0 ... smartwalk-proxy ... ... ... ... $ docker inspect --format \"{{json .State.Health }}\" [container_name] Nothing seems to help If the system does not work properly and you do not know what to do, clean up files and start from scratch. As the first step, remove SmartWalk images: $ docker image rm smartwalk/proxy $ docker image rm smartwalk/backend $ docker image rm smartwalk/routing Clean up unused Docker files (cached build files, dangling images and volumes, etc.): Warning Use this command with caution as it may introduce undesired changes into your Docker host. Read about side effects here . $ docker system prune --volumes","title":"Administrator's guide"},{"location":"adm/#administrators-guide","text":"Data preparation provides a step-by-step procedure on how to integrate data from six different sources and prepare it for running SmartWalk. Once data is ready, read Running the app to learn how to get the application up and running in development and production settings. If something is not working as expected, you might find Troubleshooting helpful before searching for a solution on the Web.","title":"Administrator's guide"},{"location":"adm/#prerequisites","text":"SmartWalk is essentially cross-platform. However, Unix utilities simplify certain aspects of system maintenance. We assume that the application will run on Unix-like environments, such as Linux or Windows Subsystem for Linux . Please ensure that the following programs are installed on the target system: Docker .NET SDK v6.0 Git GNU Bash, Make, Tar, and Wget Node.js v18.x (install via nvm ) Warning If mentioned, preserve versions of packages due to library dependencies. Clone the repository with submodules and navigate to its root folder: $ git clone --recurse-submodules https://github.com/zhukovdm/smartwalk.git $ cd ./smartwalk/ ADVICE: Docker-related commands require the current user to be a member of the docker group to avoid using sudo (or similar) repeatedly. See details at Manage Docker as a non-root user .","title":"Prerequisites"},{"location":"adm/#data-preparation","text":"This section explains how to prepare data for two system components: the Database (entity store and index) and the Routing engine . Warning The complexity of extracting and building data structures depends on the size of a particular region and might be time- and resource-consuming, especially when processing OSM dumps.","title":"Data preparation"},{"location":"adm/#initialization","text":"Navigate to the data folder, assuming you are in the root folder of the smartwalk repository: $ cd ./data/ Decide which part of the world you are interested in. Download the corresponding pbf -file at Geofabrik , and store it in the ./assets/osm-maps/ folder. As an example, the following command makes use of the wget utility to obtain the latest dump of the Czech Republic: $ wget \\ -O ./assets/osm-maps/czech-republic-latest.osm.pbf \\ https://download.geofabrik.de/europe/czech-republic-latest.osm.pbf Open Makefile and set the value of REGION_FILE accordingly. Some of the OSM dumps are quite large and additional refinement might be necessary. There are four variables REGION_X , where suffix X can be any of W (West), N (North), E (East), or S (South), defining a bounding box. Entities outside this box are filtered out. To switch off filtering, set W=-180.0 , N=85.06 , E=180.0 , and S=-85.06 (see EPSG3857 for details). Create folders for storing data, and restore project dependencies: $ make init","title":"Initialization"},{"location":"adm/#routing-engine","text":"Build a data structure for the routing engine: $ make routing-engine The command pulls this Docker image and builds the search structure in several consecutive phases. The results are stored in the ./assets/routing-engine/ folder. ADVICE: An instance of OSRM backend is able to load only one osrm -file at a time. This limitation can be overcome via merging (see osmosis ). ADVICE: It is possible to extract routing data for several regions and keep all files in the same folder as long as the original pbf -files have distinct names. Use environment variables to select a part of the world on engine start.","title":"Routing engine"},{"location":"adm/#entity-store-and-index","text":"Start up a containerized database instance: $ docker compose up -d ADVICE: Enter docker container ls repeatedly to print out the list of existing containers. Wait until smartwalk-database is healthy. Clean up all previous data, create new collections and indexes: $ make database-init Obtain the most popular OSM keys from Taginfo and store results in the ./assets/taginfo/ folder: $ make taginfo ADVICE: A list of tags can be extended by altering Makefile , although this is not enough to enable their full potential. The constructor of KeywordExtractor shall reflect changes as well. Never remove tags from the list as it may brake things unexpectedly. Modifying tag list is not a typical operation and may require deeper knowledge of the system. Extract entities from the pbf -file: $ make database-osm As part of the procedure, the routine makes several GET requests to the Overpass API . A query is configured to time out after 100 seconds, though the server usually responds within the first 10. ADVICE: To make queries feasible for the Overpass API, the selected bounding box is divided into smaller pieces. The recipe has two switches --rows and --cols defining the grid. Create stubs for new entities from the Wikidata knowledge graph: $ make database-wikidata-create The script attempts to fetch data from a SPARQL endpoint. Requests may time out after one minute. Large regions are more likely to result in failures. Hence, the numeric constants were specifically chosen for the test setup and may not be suitable for other cases. ADVICE: The recipe has --rows and --cols switches with functionality similar to database-osm . Enrich the current dataset with information from Wikidata : $ make database-wikidata-enrich Enrich the current dataset with information from the DBPedia knowledge graph: $ make database-dbpedia Collect supporting data to aid autocomplete functionality: $ make advice Finally, stop the database instance: $ docker compose down All relevant files are stored in the ./assets/database/ folder.","title":"Entity store and index"},{"location":"adm/#incremental-updates","text":"The system supports incremental updates to incorporate new versions of datasets. It is possible to re-run blue-highlighted commands with no impact on data integrity. The programs are designed to update only defined properties without replacing entities, acting as an idempotent function. advice should be re-generated whenever the database state is altered.","title":"Incremental updates"},{"location":"adm/#dumping-database","text":"Dump the current database state: $ make dump The command creates keyword.txt and place.txt in the ./assets/dump/ folder. If necessary, archive these files for publishing: $ cd ./assets/dump/ $ tar -czf smartwalk-[kind]-[timestamp].tar.gz *.txt","title":"Dumping database"},{"location":"adm/#restoring-database","text":"Clean up the database and restore the state from files: $ make database-init && make restore The restore procedure expects both files to be in the ./assets/dump/ folder. Otherwise, it fails. Examples of archived dumps can be found here . Those having prod in their names are the most data-rich covering beautiful Prague . If necessary, unpack a downloaded archive as follows: $ cd ./assets/dump/ $ tar -xzf smartwalk-[kind]-[timestamp].tar.gz","title":"Restoring database"},{"location":"adm/#running-the-app","text":"The purpose of this section is to explain how to start the system in development and production modes. We assume that you are in the root folder of the smartwalk repository and all relevant data have been extracted or restored and are available in their respective folders.","title":"Running the app"},{"location":"adm/#development-environment","text":"This environment is intended primarily for developers and testers. It enables controlling parts of the system independently. There are four system components involved in the setup: the frontend, backend, database, and routing engine. The first two run directly in the terminal, while the last two are Docker containers. The table below summarizes their roles and the mapping of system ports. Component Ports Role database localhost:27017 Entity store and index routing localhost:5000 Routing engine backend localhost:5017 Application logic (hot reload) frontend localhost:3000 Static files (hot reload) Note For convenience, components can be started and stopped directly from the smartwalk root folder. Please refer to Makefile . Recipe names follow the pattern [component_name]-dev[-stop] .","title":"Development environment"},{"location":"adm/#database","text":"Start and stop an instance of database using database-dev[-stop] from Makefile .","title":"Database"},{"location":"adm/#routing-engine_1","text":"Start and stop an instance of routing engine using routing-dev[-stop] from Makefile . Set OSRM_REGION_FILE in .env.development to load a region other than the Czech Republic.","title":"Routing engine"},{"location":"adm/#backend","text":"The project is located in ./app/backend/ . Run dotnet run from there to start the backend in the terminal, and stop it by pressing Ctrl+C . Read more about other commands in README.md . Warning This component requires the database to be up and running. Otherwise, it fails to start. The source code uses SMARTWALK_MONGO_CONN_STR and SMARTWALK_OSRM_BASE_URL environment variables. Adjust launchSettings.json respectively if you wish to alter the default port configuration.","title":"Backend"},{"location":"adm/#frontend","text":"Find the project in ./app/frontend/ . Run npm start from there to start the frontend in the terminal, and stop it by pressing Ctrl+C . Learn more about other commands in README.md . The source code uses REACT_APP_SMARTWALK_API_ORIGIN environment variable. Set its value in the .env.development file if you wish to run backend on another port.","title":"Frontend"},{"location":"adm/#production-environment","text":"This environment is a tightly coupled bundle consisting of four interconnected Docker containers; its detailed schema is shown in the picture below. Note The database exposes port 27017 for manual diagnostic and performance testing. Hide it if none of the mentioned reasons is your case. Start and stop production environment from the root folder of the repo: $ make prod[-stop] ADVICE: All containers implement healthcheck, run docker container ls to see their state. The respective environment variables are defined in the .env.production file.","title":"Production environment"},{"location":"adm/#troubleshooting","text":"WSL runs out of memory If your WSL consumes too much memory, Windows might suddenly terminate the entire process without prior notice. Try to mitigate the issue by extending the swap file; set swap=XXGB in the .wslconfig file. For more details, see Example .wslconfig file . A container starts for too long If any of the containers is unhealthy or starting for too long (healthcheck has failed repeatedly on the background), replace [container_name] placeholder by the name of a problematic instance and press Enter to find out the reason: $ docker container ls -a CONTAINER ID IMAGE ... NAMES ... ... ... ... 377fe35d4472 smartwalk/proxy:v1.0.0 ... smartwalk-proxy ... ... ... ... $ docker inspect --format \"{{json .State.Health }}\" [container_name] Nothing seems to help If the system does not work properly and you do not know what to do, clean up files and start from scratch. As the first step, remove SmartWalk images: $ docker image rm smartwalk/proxy $ docker image rm smartwalk/backend $ docker image rm smartwalk/routing Clean up unused Docker files (cached build files, dangling images and volumes, etc.): Warning Use this command with caution as it may introduce undesired changes into your Docker host. Read about side effects here . $ docker system prune --volumes","title":"Troubleshooting"},{"location":"prg/","text":"Programmer's guide This guide introduces the main parts of the application and provides sufficient implementation details to ensure a gentle learning curve for novice contributors. Prerequisites To acquire the tools necessary for setting up the environment, preparing the dataset, and writing and testing source code, follow the steps outlined in Prerequisites . Environment Learn more about the development environment at Running the app . This section explains how to configure, start, and terminate individual parts of the system. Repository structure The repository has the structure depicted below. Please note that the list is not exhaustive. ./ \u251c\u2500\u2500 Makefile . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . System maintenance \u251c\u2500\u2500 app/ \u2502 \u251c\u2500\u2500 backend/ . . . . . . . . . . . . . . . . . . . . . . . . . . . . Web API application \u2502 \u2502 \u251c\u2500\u2500 Dockerfile . . . . . . . . . . . . . . . . . . . . . . *backend* image definition \u2502 \u2502 \u251c\u2500\u2500 README.md \u2502 \u2502 \u251c\u2500\u2500 SmartWalk.Api/ \u2502 \u2502 \u251c\u2500\u2500 SmartWalk.Application/ \u2502 \u2502 \u251c\u2500\u2500 SmartWalk.Core/ \u2502 \u2502 \u251c\u2500\u2500 SmartWalk.Infrastructure/ \u2502 \u2502 \u251c\u2500\u2500 SmartWalk.<Project>.Test/ . . . . . . . . . . . . . . . . . . . . Automated tests \u2502 \u2502 \u2514\u2500\u2500 WolfGarbe.PruningRadixTrie/ . . . . . . . . . . . . . . . . . External dependency \u2502 \u2514\u2500\u2500 frontend/ . . . . . . . . . . . . . . . . . . . . . . . . . . Single-page application \u2502 \u251c\u2500\u2500 Dockerfile . . . . . . . . . . . . . . . . . . . . . . . *proxy* image definition \u2502 \u251c\u2500\u2500 README.md \u2502 \u251c\u2500\u2500 config/ \u2502 \u2502 \u2514\u2500\u2500 nginx/ . . . . . . . . . . . . . . . . . . . . . . . . . Nginx configuration \u2502 \u251c\u2500\u2500 public/ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Static files \u2502 \u2514\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 components/ . . . . . . . . . . . . . . . . . . . . . . . . React components \u2502 \u2502 \u251c\u2500\u2500 __tests__/ . . . . . . . . . . . . . . . . . . . . . A nested test folder \u2502 \u2502 \u2502 \u2514\u2500\u2500 PanelDrawer.test.tsx \u2502 \u2502 \u2514\u2500\u2500 PanelDrawer.tsx \u2502 \u251c\u2500\u2500 domain/ . . . . . . . . . . . . . . . . . . . . . . . . Types and interfaces \u2502 \u251c\u2500\u2500 features/ . . . . . . . . . . . . . . . . . . . . . . . . . Hooks and slices \u2502 \u2514\u2500\u2500 utils/ \u251c\u2500\u2500 data/ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Data pipelines \u2502 \u251c\u2500\u2500 advice/ \u2502 \u251c\u2500\u2500 dbpedia/ \u2502 \u251c\u2500\u2500 dump/ \u2502 \u251c\u2500\u2500 osm/ \u2502 \u251c\u2500\u2500 restore/ \u2502 \u251c\u2500\u2500 taginfo/ \u2502 \u251c\u2500\u2500 wikidata-create/ \u2502 \u2514\u2500\u2500 wikidata-enrich/ \u251c\u2500\u2500 infra/ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Environment files \u2502 \u2514\u2500\u2500 Dockerfile.routing . . . . . . . . . . . . . . . . . . . . *routing* image definition \u2514\u2500\u2500 misc/ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Miscellanea Architecture The architecture of the application is demonstrated using elements of the C4 model . SmartWalk is composed of four interconnected containers: the Frontend , Backend , Database , and Routing . The first two are containerized applications from the ./app/ folder. The last ones are containers based on osrm-backend and mongo Docker images that supply business logic with actual data. Frontend The frontend is a React-based single-page application, serving as an entry point and offering a rich user experience. Its source code is located in the ./app/frontend/ folder. (!) Code documentation generated by TypeDoc is available at prg-frontend . The following abstractions carry out the intended functionality. Map is responsible for loading tiles and drawing markers and vector geometries on a map. The LeafletMap is a concrete implementation capable of interacting with the OSM map. Storage is an abstraction that unifies methods for accessing both device storage and decentralized Solid pod. Data are stored on a device in IndexedDB, a standardized in-browser database, with the help of the DeviceStorage and pushed to a pod by the SolidStorage . Please note that IndexedDB and a Solid pod are mutually exclusive storages. SmartWalkAPI is a set of functions defined in the smartwalk.ts file for retrieving data from the backend via HTTP protocol. Finally, the PanelDrawer and SessionProvider are React components with visual part. The former implements the panel-based user interface and client-side routing, while the latter ensures the Solid login dialog and handles the proper switch over to the Solid Session panel. To keep panel state and resolve storage read operations locally , we use the Redux Toolkit state container composed of slices . A distinct slice is implemented for each panel, see files ending with Slice.ts in the ./src/features/ folder. Redux Toolkit is not recommended for keeping non-serializable data, such as class instances. For this reason, Map , Storage , and cached backend responses are stored in the standard Context API. Standard React hooks were found to be insufficient to cover the needs of the application. For custom hooks, see source files whose names end with Hooks.ts in the ./src/features/ folder. Backend All searching and planning functionality resides within the backend, a Web API application based on the ASP.NET Core framework. Its source code is located in the ./app/backend/ folder and consists of the following four projects: SmartWalk.Core defines entities, algorithms, solvers, and core-level abstract interfaces used across the application. SmartWalk.Application prescribes the shape of valid query objects, provides domain-level input parsers and validators, along with separate handlers for each type of supported queries. SmartWalk.Infrastructure implements gateways to the infrastructural containers. SmartWalk.Api serves as the presentation layer with HTTP endpoints, middlewares, and controllers. (!) Code documentation generated by Doxygen is available at prg-backend . The application comprises five request pipelines with the following generic structure. TController receives a request object and performs validation to reject malformed input early. Well-formed data is then handed over to the corresponding domain-level THandler , a realization of a targeted use case. TResponder is responsible for completing the response object based on three possible outcomes: a valid result of a calculation, an internal server error, or failed validation. Finally, Gateways are entities of the data access layer that implement abstract interfaces. The application utilizes the following four gateways: The TrieKeywordAdvicer is a simple wrapper over PruningRadixTrie for finding the k most relevant keywords. The MongoEntityStore and MongoEntityIndex are gateways to the database for fetching places by smartId and searching those places satisfying user-defined attribute filters. The OsrmRoutingEngine is a HTTP-based component for calling OSRM routing API. We define five HTTP-based endpoints with the supported application/json media type to facilitate the needs of the frontend. GET /api/advice/keywords \u2003\u2003\u2003 suggest the count most relevant keywords starting with prefix . GET /api/search/routes, /places, /direcs \u2003\u2003\u2003 handle search queries, with the only query parameter. GET /api/entity/places/{smartId} \u2003\u2003\u2003 fetch the full representation of a place by smartId . The API is documented using the Swashbuckle library, a toolset compatible with the OpenAPI specification. Swagger documentation is available at swagger.yaml whenever Backend container is up and running in development mode or at SwaggerHub . ADVICE: Unfortunately, not all endpoints provide examples. To support caching, search queries are passed around as serialized and percent-encoded JSON objects. Their internal structure is given in routes.json , places.json , and direcs.json . Alternatively, you could refer to type definitions. Data pipelines Besides the application source code, there are small task-oriented programs in the ./data/ folder to carry out the Data preparation phase. taginfo/ loads key statistics from Taginfo into key-specific .json files. osm/ combines information stored in Taginfo files, OSM binary files, and fetched from Overpass API to create new places or update existing ones. wikidata-create/ creates simple stubs for places that do not exist yet. wikidata-enrich/ updates the current dataset with the latest information from the Wikidata knowledge graph. dbpedia/ does the same action as wikidata-enrich/ but for DBPedia. advice/ collects statistics about keywords and attributes across the dataset and recreates advice items. dump/ dumps places and keywords into .txt files. restore/ restores place and keyword collections from .txt dump files. Testing Tests for the frontend functions and components are located in nested __tests__/ folders. To run them, navigate to the ./app/frontend/ folder and enter: $ npm run tests Backend tests are located in dedicated projects whose names end with .Test . To run them, navigate to the ./app/backend/ folder and enter: $ dotnet test","title":"Programmer's guide"},{"location":"prg/#programmers-guide","text":"This guide introduces the main parts of the application and provides sufficient implementation details to ensure a gentle learning curve for novice contributors.","title":"Programmer's guide"},{"location":"prg/#prerequisites","text":"To acquire the tools necessary for setting up the environment, preparing the dataset, and writing and testing source code, follow the steps outlined in Prerequisites .","title":"Prerequisites"},{"location":"prg/#environment","text":"Learn more about the development environment at Running the app . This section explains how to configure, start, and terminate individual parts of the system.","title":"Environment"},{"location":"prg/#repository-structure","text":"The repository has the structure depicted below. Please note that the list is not exhaustive. ./ \u251c\u2500\u2500 Makefile . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . System maintenance \u251c\u2500\u2500 app/ \u2502 \u251c\u2500\u2500 backend/ . . . . . . . . . . . . . . . . . . . . . . . . . . . . Web API application \u2502 \u2502 \u251c\u2500\u2500 Dockerfile . . . . . . . . . . . . . . . . . . . . . . *backend* image definition \u2502 \u2502 \u251c\u2500\u2500 README.md \u2502 \u2502 \u251c\u2500\u2500 SmartWalk.Api/ \u2502 \u2502 \u251c\u2500\u2500 SmartWalk.Application/ \u2502 \u2502 \u251c\u2500\u2500 SmartWalk.Core/ \u2502 \u2502 \u251c\u2500\u2500 SmartWalk.Infrastructure/ \u2502 \u2502 \u251c\u2500\u2500 SmartWalk.<Project>.Test/ . . . . . . . . . . . . . . . . . . . . Automated tests \u2502 \u2502 \u2514\u2500\u2500 WolfGarbe.PruningRadixTrie/ . . . . . . . . . . . . . . . . . External dependency \u2502 \u2514\u2500\u2500 frontend/ . . . . . . . . . . . . . . . . . . . . . . . . . . Single-page application \u2502 \u251c\u2500\u2500 Dockerfile . . . . . . . . . . . . . . . . . . . . . . . *proxy* image definition \u2502 \u251c\u2500\u2500 README.md \u2502 \u251c\u2500\u2500 config/ \u2502 \u2502 \u2514\u2500\u2500 nginx/ . . . . . . . . . . . . . . . . . . . . . . . . . Nginx configuration \u2502 \u251c\u2500\u2500 public/ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Static files \u2502 \u2514\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 components/ . . . . . . . . . . . . . . . . . . . . . . . . React components \u2502 \u2502 \u251c\u2500\u2500 __tests__/ . . . . . . . . . . . . . . . . . . . . . A nested test folder \u2502 \u2502 \u2502 \u2514\u2500\u2500 PanelDrawer.test.tsx \u2502 \u2502 \u2514\u2500\u2500 PanelDrawer.tsx \u2502 \u251c\u2500\u2500 domain/ . . . . . . . . . . . . . . . . . . . . . . . . Types and interfaces \u2502 \u251c\u2500\u2500 features/ . . . . . . . . . . . . . . . . . . . . . . . . . Hooks and slices \u2502 \u2514\u2500\u2500 utils/ \u251c\u2500\u2500 data/ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Data pipelines \u2502 \u251c\u2500\u2500 advice/ \u2502 \u251c\u2500\u2500 dbpedia/ \u2502 \u251c\u2500\u2500 dump/ \u2502 \u251c\u2500\u2500 osm/ \u2502 \u251c\u2500\u2500 restore/ \u2502 \u251c\u2500\u2500 taginfo/ \u2502 \u251c\u2500\u2500 wikidata-create/ \u2502 \u2514\u2500\u2500 wikidata-enrich/ \u251c\u2500\u2500 infra/ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Environment files \u2502 \u2514\u2500\u2500 Dockerfile.routing . . . . . . . . . . . . . . . . . . . . *routing* image definition \u2514\u2500\u2500 misc/ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Miscellanea","title":"Repository structure"},{"location":"prg/#architecture","text":"The architecture of the application is demonstrated using elements of the C4 model . SmartWalk is composed of four interconnected containers: the Frontend , Backend , Database , and Routing . The first two are containerized applications from the ./app/ folder. The last ones are containers based on osrm-backend and mongo Docker images that supply business logic with actual data.","title":"Architecture"},{"location":"prg/#frontend","text":"The frontend is a React-based single-page application, serving as an entry point and offering a rich user experience. Its source code is located in the ./app/frontend/ folder. (!) Code documentation generated by TypeDoc is available at prg-frontend . The following abstractions carry out the intended functionality. Map is responsible for loading tiles and drawing markers and vector geometries on a map. The LeafletMap is a concrete implementation capable of interacting with the OSM map. Storage is an abstraction that unifies methods for accessing both device storage and decentralized Solid pod. Data are stored on a device in IndexedDB, a standardized in-browser database, with the help of the DeviceStorage and pushed to a pod by the SolidStorage . Please note that IndexedDB and a Solid pod are mutually exclusive storages. SmartWalkAPI is a set of functions defined in the smartwalk.ts file for retrieving data from the backend via HTTP protocol. Finally, the PanelDrawer and SessionProvider are React components with visual part. The former implements the panel-based user interface and client-side routing, while the latter ensures the Solid login dialog and handles the proper switch over to the Solid Session panel. To keep panel state and resolve storage read operations locally , we use the Redux Toolkit state container composed of slices . A distinct slice is implemented for each panel, see files ending with Slice.ts in the ./src/features/ folder. Redux Toolkit is not recommended for keeping non-serializable data, such as class instances. For this reason, Map , Storage , and cached backend responses are stored in the standard Context API. Standard React hooks were found to be insufficient to cover the needs of the application. For custom hooks, see source files whose names end with Hooks.ts in the ./src/features/ folder.","title":"Frontend"},{"location":"prg/#backend","text":"All searching and planning functionality resides within the backend, a Web API application based on the ASP.NET Core framework. Its source code is located in the ./app/backend/ folder and consists of the following four projects: SmartWalk.Core defines entities, algorithms, solvers, and core-level abstract interfaces used across the application. SmartWalk.Application prescribes the shape of valid query objects, provides domain-level input parsers and validators, along with separate handlers for each type of supported queries. SmartWalk.Infrastructure implements gateways to the infrastructural containers. SmartWalk.Api serves as the presentation layer with HTTP endpoints, middlewares, and controllers. (!) Code documentation generated by Doxygen is available at prg-backend . The application comprises five request pipelines with the following generic structure. TController receives a request object and performs validation to reject malformed input early. Well-formed data is then handed over to the corresponding domain-level THandler , a realization of a targeted use case. TResponder is responsible for completing the response object based on three possible outcomes: a valid result of a calculation, an internal server error, or failed validation. Finally, Gateways are entities of the data access layer that implement abstract interfaces. The application utilizes the following four gateways: The TrieKeywordAdvicer is a simple wrapper over PruningRadixTrie for finding the k most relevant keywords. The MongoEntityStore and MongoEntityIndex are gateways to the database for fetching places by smartId and searching those places satisfying user-defined attribute filters. The OsrmRoutingEngine is a HTTP-based component for calling OSRM routing API. We define five HTTP-based endpoints with the supported application/json media type to facilitate the needs of the frontend. GET /api/advice/keywords \u2003\u2003\u2003 suggest the count most relevant keywords starting with prefix . GET /api/search/routes, /places, /direcs \u2003\u2003\u2003 handle search queries, with the only query parameter. GET /api/entity/places/{smartId} \u2003\u2003\u2003 fetch the full representation of a place by smartId . The API is documented using the Swashbuckle library, a toolset compatible with the OpenAPI specification. Swagger documentation is available at swagger.yaml whenever Backend container is up and running in development mode or at SwaggerHub . ADVICE: Unfortunately, not all endpoints provide examples. To support caching, search queries are passed around as serialized and percent-encoded JSON objects. Their internal structure is given in routes.json , places.json , and direcs.json . Alternatively, you could refer to type definitions.","title":"Backend"},{"location":"prg/#data-pipelines","text":"Besides the application source code, there are small task-oriented programs in the ./data/ folder to carry out the Data preparation phase. taginfo/ loads key statistics from Taginfo into key-specific .json files. osm/ combines information stored in Taginfo files, OSM binary files, and fetched from Overpass API to create new places or update existing ones. wikidata-create/ creates simple stubs for places that do not exist yet. wikidata-enrich/ updates the current dataset with the latest information from the Wikidata knowledge graph. dbpedia/ does the same action as wikidata-enrich/ but for DBPedia. advice/ collects statistics about keywords and attributes across the dataset and recreates advice items. dump/ dumps places and keywords into .txt files. restore/ restores place and keyword collections from .txt dump files.","title":"Data pipelines"},{"location":"prg/#testing","text":"Tests for the frontend functions and components are located in nested __tests__/ folders. To run them, navigate to the ./app/frontend/ folder and enter: $ npm run tests Backend tests are located in dedicated projects whose names end with .Test . To run them, navigate to the ./app/backend/ folder and enter: $ dotnet test","title":"Testing"},{"location":"usr/","text":"User's documentation The application provides the same level of user experience on desktop and mobile devices. Route search Navigate to the panel for searching routes: Add a starting point and destination either on the map or one of your Favorites : Custom points added directly on the map (not one of the Favorites ) are movable . Furthermore, you can clean up an occupied slot or swap points. Add categories of places that should appear on any found route: A category is composed of a keyword and keyword-specific attribute filters. The application will match only places associated with the keyword and that satisfy all activated attribute filters. There are five possible types of attribute filters: existential (shown in the picture above), boolean, numeric, textual, and include/exclude. To edit a category, click on its name. Press the x button to delete the category. If necessary, order the categories using arrows: Once all input parameters are set, press Search to initiate a request: The result of a route search should have a structure similar to the one depicted below: You may (un-)hide points associated with a category by toggling the corresponding checkbox. If necessary, save the selected route with a custom name: The route can be modified by copying its waypoints into the direction sequence. Place search To search for places, follow a similar procedure. Navigate to the Places panel, select a center point, adjust the circle's radius, and optionally add categories. If no category is specified, the system will attempt to retrieve all matching places within the circle. The result of a place search is shown below. Navigate to the detailed view of a place by clicking the blue link. A place can be stored with a custom name or appended to the current direction sequence. Use the menu accessible via the three-dot button. Direction search Directions are searched in the same manner as the previous two types of entities. Add at least two points to the sequence and press Search . After receiving a response from the backend, paginated results are displayed in the panel. Favorites All stored entities (routes, places, and directions) appear in the Favorites panel. Basic operations, such as view, edit, append (or modify), and delete, are available from the drop-down menu. Create a custom place (home, work, etc.) with a name and location through the simple dialog in the My Places collapsible region. Solid pod (advanced) By default, personal data is stored locally on your device in IndexedDB , a standardized in-browser database. Additionally, the application supports external Solid pods. Solid enables you to regain true data ownership. Learn more about this technology at https://solidproject.org/about . SmartWalk supports Inrupt PodSpaces out of the box, which is currently in Developer Preview. The application has also been tested on Community and Node Solid servers, yielding positive outcomes. (!) The application assumes that your data is stored in the ${storage-root}/smartwalk/ container. Create a profile and Solid pod at https://start.inrupt.com/profile . Log in to a Solid server, grant the application access to your pod, and wait until the Solid Session panel is opened. Now, the application is connected to the server. Select a Solid pod from the drop-down list and press the Activate Pod button. The application will initialize the pod, redirect to the Favorites panel, and download entities into the local state. After that, you can use your Solid pod as if it were device storage. To log out, press the Solid button in the upper right corner, and then click the Log Out button.","title":"User's documentation"},{"location":"usr/#users-documentation","text":"The application provides the same level of user experience on desktop and mobile devices.","title":"User's documentation"},{"location":"usr/#route-search","text":"Navigate to the panel for searching routes: Add a starting point and destination either on the map or one of your Favorites : Custom points added directly on the map (not one of the Favorites ) are movable . Furthermore, you can clean up an occupied slot or swap points. Add categories of places that should appear on any found route: A category is composed of a keyword and keyword-specific attribute filters. The application will match only places associated with the keyword and that satisfy all activated attribute filters. There are five possible types of attribute filters: existential (shown in the picture above), boolean, numeric, textual, and include/exclude. To edit a category, click on its name. Press the x button to delete the category. If necessary, order the categories using arrows: Once all input parameters are set, press Search to initiate a request: The result of a route search should have a structure similar to the one depicted below: You may (un-)hide points associated with a category by toggling the corresponding checkbox. If necessary, save the selected route with a custom name: The route can be modified by copying its waypoints into the direction sequence.","title":"Route search"},{"location":"usr/#place-search","text":"To search for places, follow a similar procedure. Navigate to the Places panel, select a center point, adjust the circle's radius, and optionally add categories. If no category is specified, the system will attempt to retrieve all matching places within the circle. The result of a place search is shown below. Navigate to the detailed view of a place by clicking the blue link. A place can be stored with a custom name or appended to the current direction sequence. Use the menu accessible via the three-dot button.","title":"Place search"},{"location":"usr/#direction-search","text":"Directions are searched in the same manner as the previous two types of entities. Add at least two points to the sequence and press Search . After receiving a response from the backend, paginated results are displayed in the panel.","title":"Direction search"},{"location":"usr/#favorites","text":"All stored entities (routes, places, and directions) appear in the Favorites panel. Basic operations, such as view, edit, append (or modify), and delete, are available from the drop-down menu. Create a custom place (home, work, etc.) with a name and location through the simple dialog in the My Places collapsible region.","title":"Favorites"},{"location":"usr/#solid-pod-advanced","text":"By default, personal data is stored locally on your device in IndexedDB , a standardized in-browser database. Additionally, the application supports external Solid pods. Solid enables you to regain true data ownership. Learn more about this technology at https://solidproject.org/about . SmartWalk supports Inrupt PodSpaces out of the box, which is currently in Developer Preview. The application has also been tested on Community and Node Solid servers, yielding positive outcomes. (!) The application assumes that your data is stored in the ${storage-root}/smartwalk/ container. Create a profile and Solid pod at https://start.inrupt.com/profile . Log in to a Solid server, grant the application access to your pod, and wait until the Solid Session panel is opened. Now, the application is connected to the server. Select a Solid pod from the drop-down list and press the Activate Pod button. The application will initialize the pod, redirect to the Favorites panel, and download entities into the local state. After that, you can use your Solid pod as if it were device storage. To log out, press the Solid button in the upper right corner, and then click the Log Out button.","title":"Solid pod (advanced)"}]}